
线程安全：单多个线程访问同一个对象，不用进行额外的操作，都可以获得正确的结果，这个对象就是线程安全的

线程间共享的数据可以分为以下5类：
	1.不可变
		final关键字修饰的变量
		如果是一个对象，需要保证对象的行为不会对其状态产生影响（例如：将对象中带有状态的变量都声明为final）
		
	2.绝对线程安全
		完全满足线程安全的定义
		
	3.相对的线程安全
		//保证对对象单独的操作是线程安全的，在一些特定顺序的连续调用需要使用额外的同步手段，来保证调用的正确性
		我们通常上讲的就是相对线程安全
		
	4.线程兼容
		//对象本身并不是线程安全的，但是可以在调用端使用同步手段来保证安全
		
	5.线程对立
		//无论采用什么措施，都无法在多线程环境下使用
		
		
线程安全的实现方法
	1.互斥同步
		//也称为阻塞同步
		//保证共享数据在同一时刻只被一个线程使用
		synchronized关键字是最基本的互斥同步手段
			synchronized是一个耗时较长的重量级操作（阻塞中的挂起线程和恢复线程）
			
	2.非阻塞同步
		//不加锁，先进行操作，如果没有其他线程争用则操作成功，如果产生冲突在采取补救措施（一般是：不断重试直到成功）
	
	3.无同步方案
		//有一些代码天生就是线程安全的
		
		
锁优化
	1.自旋锁和自适应自旋
		//如果机器有一个以上cpu时，让获得锁失败的线程执行一个忙循环（自旋）（不放弃cpu时间，不挂起线程），等待锁的释放
		自旋次数通过-XX:PreBlockSpin 来指定（默认为10）
		
		自适应自旋：通过上一次自旋时间和锁的拥有者状态确定自旋次数
			线程如果自旋成功了，那么下次自旋的次数会更加多，
			反之，如果对于某个锁，很少有自旋能够成功的，那么在以后要获取这个锁的时候自旋的次数会减少甚至省略掉自旋过程，以免浪费处理器资源。 
		
	2.锁消除
		//虚拟机即时编译器在运行时，对一些不必要的锁消除掉
		
	3.锁粗化
		//将锁的代码块扩大到一定区域
	
	4.轻量级锁
	
	5.偏向锁


	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	