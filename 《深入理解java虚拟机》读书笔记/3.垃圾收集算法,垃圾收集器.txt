垃圾回收一般指java堆和方法区这些线程共享的存储区

java堆分为新生代和老年代
	新生代又分为 Eden区、ServivorFrom、ServivorTo三个区
	Eden区和一个Servivor区空间比例为8：1

回收java堆
	判断对象是否存活
		引用计数算法（主流虚拟机都没有采用这一算法）
			缺点：无法解决对象循环引用的问题
			
		可达性分析算法（从GC Roots开始向下搜索，没有任何引用链相连的对象以死）
			//可以作为Root的有
				1.虚拟机栈（栈帧中的本地变量表）中引用的对象。
				2.本地方法栈中JNI（即一般说的native方法）引用的对象。
				3.方法区中的静态变量和常量引用的对象。
		
	引用的分类
		强引用
			永远不会回收
		
		软引用
			在将要内存溢出时会进行回收
		
		弱引用
			不管是否将要溢出都会回收
			
		虚引用
			是否存在虚引用不会对对象生存时间构成影响
			唯一作用：对象在被回收时收到一个系统通知
			

	对象回收过程
		可达性分析发现没有引用链
		->第一次标记
		->有finalize方法（没有或已被调用跳过下一步）
		->对象放入F-Queue，由虚拟机一个低优先级的线程执行对象的finalize方法(只保证触发，不保证执行结束)
		->做可达性分析，第二次标记
		->回收
		
	对象的finalize只会被调用一次如果第二次标记被移除则下次回收不会调用finalize方法
	
回收方法区
	主要回收废弃常量和无用类
	
	无用类判定
		该类实例都被回收
		加载该类的ClassLoader已被回收
		该类的java.lang.Class对象没有被引用，其他地方不能用反射访问该类的方法
		
垃圾收集算法
	标记-清除算法
		缺点：效率低，会产生空间碎片
		
	复制算法（将空间分为2半，一半要溢出了就把存活的复制到令一半空间）//适用于新生代
		缺点：空间缩小为原来的一办
	
	标记-整理算法（将存活对象向一端移动，然后清理内存）  //适用于老生代
		
	分代收集算法
	
	
		
HotSpot的算法实现
	枚举根节点（一般为全局引用（常量，类静态属性）与执行上下文（栈帧中的本地变量表））
		根节点及引用很多而且枚举根节点时都会线程停顿（stop the work）
		利用OopMap来缩短时间，OopMap会记录下引用的位置
	
	安全点（safepoint） //Oopmap记录的时候为安全点
		只有在安全点时才能暂停下来GC
		一般指令复用时才会产生安全点（方法调用，循环跳转，异常跳转）
		调用GC需要所有的线程都到最近的安全点在停顿下来
			抢先式中断（GC发生时中断全部线程，发现线程不在安全点，就恢复线程，让他跑到安全点）
				几乎没有虚拟机使用这种方式
				
			主动式中断
				（GC需要操作时不会对线程直接操作，会设置一个标志，线程轮询这个标志，为True时自动中断挂起（轮询时间和安全点重合））
				
	安全区域（在一段代码片段中引用关系不会发生改变）
		安全点的扩展，解决了程序暂停时（sleep）JVM不用等待线程重新运行
		在安全区域时可以进行GC
		退出安全区域时检查是否在GC中，等待GC结束
		
		
		
垃圾收集器
	新生代收集器（复制算法）
		Serial收集器
		ParNew收集器
		Parallel Scavenge收集器
		
		
	老年代收集器（标记-整理算法）
		Serial Old收集器
		Parallel Old收集器
		CMS收集器  （标记-清除算法）
		
		G1收集器 （最新技术（用于取代CMS））
		
		
		Serial收集器（单线程）
			收集时暂停全部工作线程
			虚拟机运行在Client模式下的默认新生代收集器
		
		ParNew收集器
			Serial收集器的多线程版本
			虚拟机运行在Servers模式下的默认新生代收集器
		
		Parallel Scavenge收集器（吞吐量优先）
			自适应调节
				-XX:+UseAdaptiveSizePolcy
				设置这一参数后不用设置新生代老年代大小，会自适应
				
		Serial Old收集器
			虚拟机运行在Client模式下的默认老年代收集器
			Servers模式下2个用途
				JDK1.5之前与Parallel Scavenge收集器搭配使用
				作为CMS收集器的后备方案

		
		Parallel Old收集器（吞吐量优先）
			用于搭配Parallel Scavenge收集器


		CMS收集器  （标记-清除算法）//目标为最短停顿时间    //会在Full GC时进行内存碎片的整理合并
			清除步骤： //时间最长的并发标记和并发清除和用户进程一起工作
				初始标记 //暂停线程
					只是标记GC Roots能直接关联到的对象，速度很快
				
				并发标记
					GC Roots Tracting
				
				重新标记
					标记并发标记期间用户进程产生的变动
					会比初始标记时间长
					
				并发清除

		G1收集器 （最新技术（用于取代CMS））
			优点：
				并行与并发
					缩短STW（Stop the Word）时间
				分代收集
					可以不需要其他收集器配合就能管理整个GC堆
				空间整合
					基于标记-整理算法
				可预测停顿
				
				
虚拟机垃圾收集器日志参数
	-XX:+PrintGCDetails  //发生垃圾收集时打印日志
	
				
				
内存分配与回收策略
	对象优先在新生代的Eden分配
		新生代的Eden空间不足时发起Minor GC
				
	大对象直接进入老年代 //避免由于新生代使用复制收集算法而引发大量内存复制
		虚拟机参数
			-XX:PrentenureSizeThreshold=3145728 //大于3M进入老年代
				
	长期存活对象进入老年代
		虚拟机为每个对象维护一个对象年龄计数器
		每熬过一次Minor GC年龄加一
		虚拟机参数
			-XX:MaxTenuringThreshold=2 //对象年龄=2时晋升代老年代
	
	动态对象年龄判断
		如果survivor空间中相同年龄大小总和超过survivor空间的一半，大于等于这个年龄的都进入老年代
		不用等到MaxTenuringThreshold
		
	空间分配担保
		在发生Minor前会检查老年代最大可用连续距离是否大于全部新生代对象总和
		虚拟机会检查参数 -XX:-HandlePromotionFailure=false 是否允许担保失败
		允许则检查老年代最大可用连续距离是否大于历代晋升老年代对象平均大小，
		如果小于则进行Full GC
				
				
				
				
				
				
				
				
				
				
				
				
				
				
				
				
				
				
				
				
			















		
		
		
		
		
		
		
		
	
