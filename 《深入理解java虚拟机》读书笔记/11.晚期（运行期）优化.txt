晚期（运行期）优化
	//
	即时编译器（JIT编译器）：虚拟机会将频繁运行的代码块（热点代码）用JIT编译器编译为机器码，用以提高代码的执行效率
	java虚拟机规范中没有规定必须有JIT编译器存在，但JIT编译器是衡量虚拟机性能的重要指标
	
	
	HotSpot中的JIT编译器
		//HotSpot中解释器与编译器共存，互相配合工作
		解释器优点：可以省去编译时间用于快速启动，解释执行节约内存，
		编译器优点：执行效率更高
		
		HotSpot中有2个JIT编译器，解释器和其中一个编译器配合工作
			Client Compiler
			Server Compiler
			
			虚拟机参数
				-client   //强制使用Client Compiler编译器
				-server   //强制使用Server Compiler编译器
				
				-Xint     //强制运行与解释模式下
				-Xcomp    //强制运行与编译模式下
			
		分层编译：根据优化程度与耗时分层（JDK1.7中Server模式默认开启）
			0.程序解释执行，解释器不开启性能监控功能，可触发第一层编译
			1.将字节码转变为本地代码，进行简单可靠的优化，如有必要加入性能监控功能
			2.将字节码转变为本地代码，会启用一些耗时较长的优化，会根据性能监控进行一些不可靠的激进优化
			
			
	编译对象与触发条件               //不会编译所有的字节码
		热点代码：
			多次调用的代码
			多次执行的方法体   //也是会以整个方法体作为编译对象
			
		热点探测：判断是否需要触发即时编译
			基于采样的热点探测
				//周期性检查各个线程的栈顶，如果某个方法经常出现就是“热点方法”
				简单，高效，容易获取方法的调用关系
				很难确定一个方法的热度
				
			基于计数器的热点探测（HotSpot中使用这种）
				//为每个方法（甚至代码块）设置计数器，统计执行次数，超过摸个阈值，就是“热点方法”
				更加精准
				不能获取调用关系，统计比较麻烦
			
			
			//Client模式下：方法被调用时会检查该方法是否被编译过，如有则使用编译后的本地代码执行，如果没有则调用方法计数器+1，检查是否超过阈值，如超过则提交给JIT编译器编译，方法继续进入解释器执行直到编译完成
			
			
			
			HotSpot中为每个方法设置2个计数器
				方法调用计数器
					阈值：Client模式下1500次 Server模式下10000次
					如果不进行设置，方法调用计数器记录的并不是绝对次数，而是相对频率
						如果一段时间内（半衰周期）次数仍达不到阈值，则计数器减半（计数器热度的衰减）
						-XX:-UseCounterDecay  //关闭热度衰减，使计数器记录绝对次数
						-XX:CounterHalfLifeTime   //设置半衰周期
				
				回边计数器//循环体执行次数
					
	

	编译过程
		//编译在一个单独的线程里进行，未完成前都是使用解释器
		-XX:BackgroundCompilation   //禁止后台编译，未完成编译前等待
		
		Cilent Compiler
			1.将字节码构造成一种高级中间代码表示（HIR）
				使用静态单分配
				完成一部分基础优化
				
			2.HIR转成低级中间代码表示（LIR）
				完成另外一些优化
			3.在LIR上分配寄存器，在LIR上做窥孔优化
		
		Server Compiler
			专门为服务端性能做深入优化
			
		
		
优化技术
	公共子表达式消除
		//如果一个表达式重复出现，则为公共子表达式
		//例如 int d=(c*b)*12+a+(a+b*c)
			转为：int d=E*12+a+(a+E)
			
	数组边界检查消除
		
	方法內联
		//例如 int a=b.getValue()
			转为：int a=b.value
		
		
		
		
		
		
		
		
		
		
		
		
		
		
			
			
			
			