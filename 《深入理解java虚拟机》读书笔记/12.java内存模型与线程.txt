java内存模型与线程
	java内存模型：主要目标是定义变量的访问规则，既虚拟机如何存储和取出变量
		//这里的对象指的是：实例字段，金台字段，构成数组对象的元素（都是所有线程共享的）
		
		主内存和工作内存
			主内存：就是机器的内存
			工作内存：缓存（Cache），线程私有
			
			//线程的所有操作必须在工作内存中进行，线程之间的值传递通过主内存
			
			工作内存与主内存之间的交互操作
				lock(锁定)：作用于主内存变量，将一个内存标识为一条线程独占的状态
				
				unlock(解锁)：作用于主内存变量，解锁
				
				read(读取)：作用于主内存变量，将一个变量的值传输到工作内存，一遍随后的载入
				
				load(载入)：作用于工作内存变量，将在主内存中的到的变量值，放入工作内存的变量副本中
				
				use(使用)：作用于工作内存变量，将工作内存中一个变量的值传递给执行引擎
				
				assign(赋值)：作用于工作内存变量，把从执行引擎接收到的值赋给工作内存中的值
				
				atore(存储)：作用于工作内存变量，将一个工作内存的变量的值传递到主内存，以便write操作
				
				write(写入)：作用于主内存变量，从工作内存中得到的变量的值存入主内存变量中
				
				//从主内存到工作内存：顺序执行read和load
				
				//从工作内存到主内存：顺序执行store和write
				
				执行以上操作时的规则
					不允许read和load，store和write之一单独出现
					
					不允许线程丢弃assign操作，既工作内存改变必须同步到主内存
					
					不允许线程无故（没有assign）同步回主内存
					
					新变量只能在主内存中诞生
					
					一个变量同一时刻只能被一个线程lock，可以被同一个线程多次lock（需要执行相同次数的unlock）
					
					不允许unlock没有被lock的对象，不允许unlock被其他线程lock的对象
					
					lock操作会清除此变量在工作内存中的值
					
					unlock会先将变量同步回主内存
		
		
		volatile变量的运算在并发下是不安全的，因为java中的运算并非原子操作
		
		
		原子性，可见性和有序性
			原子性
				基本数据类型的访问读写是具备原子性的（除了long和double）
				在synchronized块中操作也具备原子性
				
			可见性
				//一个线程修改了共享变量的值，其他线程立即得知这个修改
				java内存模型通过变量修改后同步回主内存，变量读取前刷新变量值来实现可见性
				volatile变量保证可见性，普通变量不能保证这一点
				synchronized，final关键字保证可见性
				锁可以保证可见性
				
			有序性
				synchronized，volatile变量保证了线程之间操作的有序性
				
		先行发生（happens-before）原则
			//A的先行发生会影响到B
			
			//时间上的先发生，不代表这个操作会先行发生
			//先行发生也未必就在时间上先发生
			java虚拟机中的天然先行发生关系（虚拟机不会对他们进行重排序）
				程序次序规则
					//在一个线程内写在前面的代码先行发生于写在后面的代码
				
				管程锁定规则
					//一个unlock操作先行发生于对同一个锁的lock操作
					
				volatile变量规则
					//volatile变量的写操作先行发生于读操作
					
				线程启动，终止，中断规则
					Thread对象的start（）方法先行发生
					线程的所有操作先行发生于对此线程的终止检测
					对线程interrupt（）方法的调用先行发生于中断线程的代码检测到中断线程的发生
					
				对象终结规则
					//一个对象的初始化先行发生于finalize（）方法
					
				传递性
					//a先行发生于b，b先行发生于c，a就先行发生于c
				

java使用操作系统原生的线程模型
使用抢占式线程调度
				
				
				
				

				
				
				
				
				
				
				