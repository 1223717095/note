运行时栈帧结构
	//栈帧是虚拟机用于支持方法调用和方法执行的数据结构
	//每个方法的执行到结束，都伴随者出栈和入栈的过程
	//栈帧储存了方法的局部变量表，操作数栈，动态连接，方法返回地址
	
	//栈帧的大小在编译时确定，运行时不会改变
	
	局部变量表
		//java编译为class文件时，会在方法的Code属性的的max_locals数据项确定局部变量表的最大容量
		//局部变量表以Slot（变量槽为最小单位）
		//虚拟机规范没有明确指出Slot的大小，但可以存放一个32位以内的数据类型
		
		虚拟机是通过索引使用局部变量表的，32位时索引n代表第n个Slot，64位时索引n代表第n和n+1个Slot（不允许单独访问其中的一个，会报错）
		
		如果执行的是实例方法（非static），第0索引为方法所属对象实例的引用，在方法中通过this关键字访问
		
		为了节省栈空间Slot是可重用的，（因为某些变量作用域不会覆盖整个方法体）
		
		Slot重用有时会影响到GC操作，在局部对象占用大空间，栈帧长时间不被回收可以手动为其赋null释放空间
		
		局部变量不会像类变量一样在准备阶段赋系统初始值
		
	操作数栈
		//java编译为class文件时，会在方法的Code属性的的max_stacks数据项确定操作数栈的最大深度
		//操作数栈的元素可以是java的任意数据类型，32为数据类型占容量1，64位占容量2
		//方法刚开始执行时，操作数栈是空的
		
	动态连接
		//指向运行时常量池中该栈帧所属方法的引用
		//持有这一引用是为了支持方法调用过程中的动态引用
		
	方法返回地址
		//2种方式退出方法
			正常完成出口（遇到返回指令）
				可能会有返回值传递给上层方法调用者
			
			异常完成出口（遇到异常且在本方法异常表中没有找到匹配的异常处理器）
				不会给上层调用者任何返回值
		
		调用者的PC计数器的值可以作为返回地址
		
	栈帧信息
		//由具体的虚拟机规定
		
		
方法调用
	//调用不等同于执行
	//唯一任务是确定调用哪个方法
	//class文件的编译不包含传统编译中的连接步骤，所以方法调用过程相对复杂，需要在类加载期间甚至运行期间才能确定方法的直接引用
	//一切方法调用在class中都是符号引用
	
	解析
		//在类加载的的解析阶段，会将一部分的符号引用转为直接引用，这种解析成立的前提是这个方法“编译期可知，运行期不变”，这类方法的调用称为解析（主要包括静态方法和私有方法，实例构造器，父类方法）
		//解析调用一定是静态的过程，在类加载的解析阶段就会全部转成直接引用
		//分派可能是静态也可能是动态
		
	分派 	           //解析和分派并不是2选一的关系
		静态分派	   //利用静态类型来确定方法执行版本的分派
			//Human man=new Man();//Human为静态类型，Man为实际类型
			//静态类型在编译时可知（可能会改变例如（Man）man），实际类型要到运行期才确定
			
			确定调用方法的重载版本是根据参数的静态类型确定的
			
		动态分派      //和重写密切关联
			//在运行期通过实际类型确定方法的执行版本
			
			
		单分派和多分派
			方法的接收者与方法的参数统称为方法的宗量，
			单分派：基于一个宗量对方法进行选择
			多分派：基于多个宗量对目标进行选择
			
			静态多分派
			动态单分派
			
	动态类型语言支持
		先跳过。。。。。。
		

字节码解释执行引擎
	//class文件中的代码有可能会被解释执行，也有可能被编译执行
			
		
		
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
				