java中类型的加载，连接，初始化都是在程序运行期间完成的


类的加载时期
	类从被加载到虚拟机内存，到被卸载出虚拟机内存的7个阶段
	
		Loading（加载）
		->verification（验证）------------|
		->preparation(准备)---------------|--Linking(连接)
		->resolution(解析)----------------|
		->initialization（初始化）
		->Using（使用）
		->Unliading（卸载）
		
	除了解析其他几个阶段都是按顺序开始的(交叉进行)
	
	java虚拟机规范没有明确规定什么情况下进行类加载
	
	有且只有以下5种情况必须立即对类进行初始化（加载，验证，准备需要在此之前开始） //除此之外的为被动引用
	
		1.遇到new,getstatic,putstatic,invokestatic这4条字节码指令时,如果类没有进行过初始化,就触发其初始化
		这4条指令的java代码场景:使用new关键字,读取或设置一个类的静态字段,调用类的静态方法
		
			静态字段只有直接定义这个字段的类才会初始化,子类引用父类字段只会初始化父类
			
			创建类的数组不会引发初始化
				例如 A[] a=new a[10];
				
			读取类的静态常量不会初始化
		
			
		2.使用Java.lang.reflect对类进行反射调用时,如果类没有进行过初始化,就触发其初始化
		
		3.初始化一个类时如果其父类还没有初始化,则触发父类初始化
		
		4.虚拟机启动时会先初始化主类(包含main方法的类)
		
		5.使用JDK1.7的动态语言支持时如果一个java.lang.invoke.MethodHandle实例的解析结果为
			REF_getStatic,REF_putStatic,REF_invokeStatic的方法句柄,并且这个句柄的类没有进行过初始化则初始化这个类
			
	接口的加载与类加载区别在第3点
		接口初始化时不要求其父接口一定完成初始化
		只有真正使用到(如引用接口中定义的常量)父接口时才初始化父接口
		
		
		
类加载过程
	加载
		1.通过一个类的全限定名获取此类的二进制字节流
		
		2.将这个字节流所代表的静态存储结构转换为方法区的运行时数据结构
		
		3.在内存(不一定是java堆,也有可能是方法区)中生成一个代表这个类的javva.lang.Class对象,作为方法区这个类各种数据的访问接口
		
		加载阶段是开发人员可控性最强的,可以自定义自己的类加载器控制字节流的获取(重写一个类加载器的loadClass方法)
		
		数组类本身不通过类加载器加载,由java虚拟机直接加载
		
		数组类创建过程
			1.如果数组的组件类型(去掉一个纬度)为引用类型,则数组将在加载该组件类型的类加载器的命名空间上被标识
			
			2.组件类型不是引用类型(例如int[]),数组标记为与引导类加载器关联
			
			3.数组类可见性与组件类可见性一致,如果不是引用类型,默认为public
		
	验证
		//连接阶段的第一步,保证Class文件字节流符合虚拟机要求
		
		
		1.文件格式验证     //保证二进制字节流可以正确解析并存储与方法区
			是否以魔数0XCAFEBABY开头
			
			主次版本号是否在当前虚拟机处理范围内
			
			常量池的常量是否由不被支持的常量类型(检查常量的tag标志)
			......
			验证是基于二进制字节流的,只有这一阶段验证通过才会进入方法区储存
			之后的阶段不在直接操作字节流,而是直接基于方法区的存储结构进行
			
		2.元数据验证      //对字节码描述的信息进行语义分析
			这个类是否有父类(除了Object,所有类都应当有父类)
			
			父类是否继承了不允许被继承的类(final修饰的类)
			
			如果这个类不是抽象类是否实现了其父类或接口中要求实现的全部方法
			......
		
		3.字节码验证
			
		4.符号引用验证
		
	准备
		//为类变量(不包括实例变量)分配内存,设置变量初始值(基本数据类型的零值,初始化阶段才赋予,java代码中的初始值)
		
	解析
			//将方法区常量池的符号引用替换为直接引用的过程
			
			符号引用
				以一组符号来描述所引用的目标
				
				引用的目标不一定已经加载到内存中
				
				与虚拟机实现的内存布局无关
				
			直接引用
				可以是指向目标的指针,相对偏移量,一个能间接定位到目标的句柄
				
				目标已经在内存中
				
			虚拟机要求在执行用于操作符号指令引用的字节码指令之前,进行解析
			
			对同一个符号引用进行多次解析是正常的,会进行缓存
		
		
		1.类或接口的解析
			假设当前代码所处类为D,把一个符号引用N解析为一个类或接口C的直接引用
				1.如果C不是数组类型,虚拟机会把代表N的全限定类名传递给D的类加载器加载这个类C
				2.如果是数组且元素类型为对象
				3.确认D对C的访问权限,没权限报错
		
		2.字段解析
			
		3.初始化
			会先初始化父类(Object类最先初始化)
			赋予变量开发人员在代码中指定的初始值
			执行静态语句块(static{})
		
			
类加载器
	类加载过程"通过一个类的全限定名获取此类的二进制字节流"
	
	类与类加载器
		类的唯一性需要由加载这个类的类加载器和这个类一起确定
		
		类是否相等需要在同个类加载器的前提下
		
	双亲委派模型
		3种类加载器
			启动类加载器
				负责加载<JAVA_HOME>\lib目录中,或者被-Xbootclasspath参数指定的路径
				
			扩展类加载器
				负责加载<JAVA_HOME>\lib\ext目录中
				
			应用程序类加载器
			
		如果收到了类加载请求,会先委派给父类加载器
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		