volatile不能保证原子性所以在并发下是不安全的

java中每个对象都可以作为锁
	synchronized
		对于普通同步方法，锁是当前对象
		
		对于静态同步方法，锁是当前类的Class对象
		
		对于同步方法块，锁是synchronized（）括号中的对象
	
	
synchronized的锁是存在java对象头里的Mark Word中

锁的4种状态
	//随着竞争情况升级
	//不可降级
	1.无锁状态
	
	2.偏向锁状态
	
	3.轻量级锁状态
	
	4.重量级锁状态
	
	偏向锁
		//适用于只有一个线程访问同步快
		
		//等到竞争出现才释放锁的机制
		//当一个线程获得锁后，在对象头和栈帧种记录锁偏向的线程id
		-》以后这一线程不需要加锁和解锁，只需要测试对象头Mark Work是否储存当前线程id
		-》如果测试失败则测试Mark Work中的偏向锁是否为1（表示当前为偏向锁，0为无锁）
		-》如果没有设置则CAS竞争锁，如果设置了CAS将当前的偏向锁指向当前进程
		
		
		关闭偏向锁
			-XX:-UseBiasedLocking=false
			
	轻量级锁
		//适用于追求响应时间
	
		//在当前线程栈帧中创建用于存储锁记录的空间
		-》将对象头中的Mark Work复制到锁记录中
		-》CAS尝试Mark word替换为指向锁记录的指针
		-》如果成功则获得锁，失败则尝试自旋来获得锁
		
		
		
	重量级锁
		//适用于追求吞吐量
		
		
原子操作的实现原理
	处理器实现原子操作
		总线锁保证原子性
			//处理器提供一个LOCK#信号，单处理器在总线上输出该信号时其他处理器请求被阻塞
		缓存锁保证原子性
	
	java实现原子操作
		锁
		循环CAS
			
		
		
		
		
		
		
		
		
		
		
		
		